% For layout testing
\defbox{\boxa}{60}{40}{caption}{content content content content content content content}
\newcommand{\boxb}{\nicebox{60}{20}{caption}{test test test test}}
\newcommand{\boxc}{\nicebox{80}{40}{caption}{bla bla bla bla bla bla}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [AA] Amortizovaná zložitosť
% definícia amortizovanej zložitosti, potenciálová funkcia
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxAA}{100}{55}{Amortized Analysis}{
\textbf{Def:} DS supporting operations $o_1,\dots,o_k$.
Amortized time of $o_i$ is $t_i(n)$ if any valid sequence of $n$ operations, in which $o_i$ occurs $n_i$ times, takes total time $\bigO{\sum_j n_jt_j(n)}$.\\
\textbf{Accounting method:} Charge $t_j(n)$ for operation $o_j$. If $t_j(n) >$ cost: distribute the remainder to accounts. If $t_j(n) <$ cost: charge some accounts. Prove non-negative balance at all times.\\
\textbf{Potential method:} $D_i$ is the DS after $i$-th operation, $\Phi(D_i)$ is the DS potential (eg. sum of all accounts). Real cost $c_i$, amortized $\hat{c}_i = c_i + \Phi(D_i) - \Phi(D_{i-1})$. Total cost $\sum_i \hat{c}_i = \sum_i c_i + \Phi(D_n) - \Phi(D_0)$. If $\Phi(D_n)\ge\Phi(D_0)$ then $\hat{c}$ is upper bound on true cost. Usually $\Phi(D_{0})=0$, then need $\Phi(D_i)\ge 0$.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [RMQ] RMQ a LCA
% jednoduché algoritmy
% algoritmy s O(n) predspracovaním a O(1) dotazom
% segmentové stromy
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxRMQrmqlca}{100}{70}{RMQ and LCA}{
\textbf{Trivial:} LCA: no preprocessing, $\bigO{n}$ query; $\bigO{n^3}$ preprocessing, $\bigO{n^2}$ memory, $\bigO{1}$ query; RMQ: \circled{1} $\bigO{n^2}$/$\bigO{1}$.\\
\textbf{RMQ$\to$LCA:} Cartesian tree: root is minimum $A[i]$, left subtree is cartesian tree of $A[<i]$, right is CT of $A[>i]$ (min-heap, in-order traversal is A). Linear time construction: process $A$ left to right, walk up the right spine of the tree.\\
\textbf{LCA$\to\pm 1$RMQ:} Euler tour (DFS) to get depth array, store index of first visit for each node. $\bigO{n}$ preprocessing.\\
\textbf{RMQ in $\bigO{n\log n}$/$\bigO{1}$} \circled{2} (BIG from HW) Store answer for all intervals with length $2^k$. Combine two to answer query.\\
\textbf{$\pm 1$RMQ:} Split to $\nicefrac{2n}{\log n}$ groups of size $n' = \nicefrac{1}{2}\log n$. Store minimum from each group, use \circled{2}. Since $\pm 1$, only $2^{n'} = \sqrt{n}$ different block types (min pos), use \circled{1}: $\bigO{\log^2 n}$ different queries for each type, $\bigO{\log\log n}$ bits for answer, total $\bigO{n}$ preprocess. For final answer compare three candidate positions. 
}

\defbox{\boxRMQsegment}{100}{40}{Segment trees}{
\textbf{Root:} interval $[0,n)$, \textbf{Leafs:} intervals $[i,i+1)$\\
\textbf{Node} $[i,j)$ has children $[i,k)$ and $[k,j)$ where $k = \lfloor\frac{i+j}{2}\rfloor$, stores $A[i]\circ A[i+1]\circ \cdots \circ A[j-1]$. Total $2n-1$ nodes, height $\lceil\log n\rceil$.\\
\textbf{Query:} $A[x]\circ \cdots \circ A[y-1]$ ie $[x, y)$, canonical decomposition, $\bigO{\log n}$ time.\\
\textbf{Can dec:} node $[i,j)$, invariant: overlaps $[x,y)$. If $[i,j) \subseteq [x,y)$ return $\{[i, j)\}$. Else $R := \emptyset$, if $[i,k)$ overlaps $[x,y)$ recurse left, add result to $R$. Same for right child, then return $R$.
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [PQ] Prioritné rady
% Fibonacciho halda a jej amortizovaná analýza
% Tri verzie meldable háld: random, leftist a skew, v každej algoritmus pre zjednotenie a jeho analýza
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defbox{\boxPQmeld}{90}{70}{Meldable heaps}{
\textbf{Union($H_1, H_2$):} $\bigO{\log n}$, WLOG $H_1.key \leq H_2.key$\\
\textbf{Insert:} union with node; \textbf{ExtrMin:} union of root subtrees; \textbf{DecrKey:} delete, insert; \textbf{Delete:} cut, union subtrees, rebalance \\
\textbf{Random:} $H_2$ union with $H_1.left$ or $H_1.right$ at random, expected random root-nullptr walk length $\bigO{\log n}$ \\
\textbf{Leftist:} $HN = $ Union($H_1.right, H_2$), if $HN.s \le H_1.s$ put as right child of $H_1$ otherwise left; $s(x)$ - dist. from $x$ to nearest nullptr, $s(x) \leq \log (n+1)$, $x\to$ nullptr path only to right has lenght $s(x)$ \\
\textbf{Skew:} Union($H_1.right, H_2$), put as left child of $H_1$; $D(x)=|$subtree rooted at $x|$; edge $(v,p(v))$ heavy - $D(v) > D(p(v))/2$; root path $\leq \log n$ light edges, $\Phi=$ \# heavy right edges; cut children before recursion, add after, cost only when $H_1.r$ was light before cut
}

\defbox{\boxPQfib}{100}{70}{Fibonacci heap}{
\textbf{Structure:} list of rooted trees, node degree $\leq D(n)=\bigO{\log n}$, sibling pointers, non-root node marked iff lost child since getting father, $\Phi=$ \#roots + 2\#marked nodes \\
\textbf{Lazy:} $\bigO{1}$, Insert: new root, Min: look, Union: join root list \\
\textbf{ExtrMin:} $\bigO{\log n}$ am., remove min root, child to root list, consolidate - join trees until each different degree \\
\textbf{DecrKey(x):} $\bigO{1}$ am., decrease, if violates heap cond. cut $x$ with subtree to root list, cascading cut - try to mark $p(x)$, if alredy marked cut him to root, cascade again, rec. call cost 0 - pays with $\Phi$ change, everything else $\bigO{1}$ am. \\
\textbf{Delete:}  $\bigO{\log n}$ am., decrease key to -inf, extract min \\
\textbf{Analysis:} Prove $D(n) = \bigO{\log n}$: \textbf{1)} $\forall k \geq 2: F_{k+2} = 1 + \sum_{i=0}^k F_i, F_{k+2} \geq \phi^k$, \textbf{2)} $x$, $y_1, \dots, y_k$ child in link order, $j\geq 2: y_j.deg \geq j-2$, \textbf{3)} $x$ deg. $k$, size of subtree $\geq F_{k+2}$ (induction on smallest deg $k$ tree).
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [SPLAY] Splay stromy a link-cut stromy
% splay stromy (algoritmus, zložitosť a potenciálová funkcia, netreba celý dôkaz)
% použitie splay stromov na join a split
% link-cut stromy (štruktúra, expose, netreba analýzu zložitosti)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\defbox{\boxSPLAYsplay}{90}{50}{Splay trees}{
\textbf{BST} w/o balance info, am. $\bigO{\log n}$ ops., move el. to root after access, decr. overall height \\
\textbf{Splay(x):} zig/zag rotations until $x$ root, real cost: \# rotations, $D(x)$ size of $x$ subtree, rank $r(x) = \log D(x)$, $\Phi(T) = \sum_{x \in T} r(x)$, cost $\bigO{\log n}$ am. \\
\textbf{Search, Delete, Insert(x):} as in BST  then splay, insert increases rank on root-$x$ path, at most $\bigO{\log n}$, \textbf{fMin(x):} splay($x$), splay leftmost, ret. it, \textbf{join($v_1, v_2$):} keys $v_1 \leq v_2$, $m$=fMin($v_2$), splay($v_1$), $v_1$ as left child of $m$, \textbf{SplitBefore/After($x$):} splay(x), cut one child
}

\defbox{\boxSPLAYlink}{90}{55}{Link-cut trees}{
\textbf{Path:} splay tree, key - pos. on path (not stored), findHead, split, join same \\
\textbf{L-C:} forest, each node $\leq 1$ solid edge, other dashed; tree as coll. of solid paths, connected by dashed parent ptrs
\textbf{Expose($x$):} make $x$ lower end of solid path to root, $\bigO{\log^2 n}$ am., splitBelow($x$), jump to solid path root, splice root, repeat; \textbf{Splice($x$):} splitBelow($p(v)$), make that edge dashed, join $x$ and $p(x)$ \\
\textbf{FindRoot:} expose, findHead, \textbf{Link($v, w$):} $v$ root, make $v$ child of $w$; expose both, join paths, \textbf{Cut($v$):} $v$ not root, cut edge $v$ to parent; expose, splitAbove
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [SEARCH] Vyhľadávanie kľúčových slov	
% invertovaný index
% lexikografický strom
% prienik triedených zoznamov (doubling search/galloping search)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxSEARCHmain}{100}{55}{Full-Text Keyword Search}{
\textbf{Problem:} preprocess static set of documents (sequences of words) to answer queries: given word $w$ list all documents containing it.\\
\textbf{Inverted index:} store all words along with list of document IDs; see \refbox{inverted index} for storage options. \\
\textbf{Trie:} tree, edges labeled with letters, path from root is a string; store document IDs in nodes where word ends. For $|w|=m$, alphabet size $\sigma$, total word length $D$:\\
{
\centering
\begin{tabular}{r l l l}
\textit{Node edge storage} & \textit{Search} & \textit{Insert} & \textit{Space} \\
Array of size $\sigma$ & \bigO{m} & \bigO{m \sigma} & \bigO{D \sigma}\\
Sorted array & \bigO{m \log \sigma} & \bigO{m \log \sigma + \sigma} & \bigO{D} \\
BST & \bigO{m \log \sigma} & \bigO{m \log \sigma} & \bigO{D}
\end{tabular}
}
}

\defbox{\boxSEARCHinverted}{100}{35}{Inverted Index (Full-Text Keyword Search)}{
For $N$ words ($n$ distinct) of max length $m$ with alphabet size $\sigma$ and result count $p$:\\
{\centering
\begin{tabular}{r l l}
\textit{Index storage} & \textit{Query} & \textit{Preprocessing} \\
Sorted array & \bigO{m \log n + p} & \bigO{mN \log N} \\
BST (balanced) & \bigO{m \log n + p} & \bigO{mN \log n} \\
Hashing & \bigO{m+p}/\bigO{mn+p} & \bigO{mN}/\bigO{mNn} \\
Trie & \bigO{m \log \sigma + p} & \bigO{mn \log \sigma}
\end{tabular}
}
}

\defbox{\boxSEARCHintersection}{90}{35}{Sorted List Intersection (2 Keyword Search)}{
\textbf{Output:} intersection of two sorted lists, lengths $m \le n$.\\
\textbf{Merging:} iterate over both at once: \bigO{m+n}\\
\textbf{Binary search:} iterate over smaller, search through the larger one: \bigO{m \log n}\\
\textbf{Doubling search:} like binary search but \bigO{\log i} (where $i$ is the result) instead of \bigO{\log n} -- double search interval until it overshoots, then binary search; \bigO{m \log \nicefrac{n}{m}}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [HASH] Hešovanie	
% Perkeeftné hešovanie: algoritmus, odhad očakávanej veľkosti pamäte pri univerzálnej triedy hešovacích funkcií
% Bloom Filters - algoritmus, približný odhad pravdepodobnosti chyby
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxHASHph}{90}{35}{Perfect Hashing}{
\textbf{Top level:} universal hash function to table of size $\Theta(N)$ \\
\textbf{Second level:} bucket $i$ with $c_i$ elements hashed to a table of size $\alpha c_i^2$. Expected \# of collisions: $\sum_{\substack{u,v \in X_i\\ u \ne v}} Pr[h(u) = h(v)] \le c_i^2 \frac{c}{m_i} = \frac{c}{\alpha} = \bigO{1}$ \\
\textbf{Search:} $\bigO{1}$ \textbf{Space:} $\bigO{n}$ (deterministic)\\
\textbf{Expected preprocessing time:} $\bigO{n}$\\
}
\defbox{\boxHASHbf}{90}{40}{Bloom Filters}{
\textbf{Representation:} bit string $B[0,\dots,m-1]$ and k hash functions $h_i : U \to \{0, \dots , m-1 \}$ \\
\textbf{Insert(x):} set bits $B[h_1(x)], \dots , B[h_k(x)]$ to 1  \\
\textbf{Contains(x):} check if $B[h_1(x)], \dots , B[h_k(x)]$ are all 1 \\
- if yes, claim x is in the set, \emph{possibility of error} \\
- otherwise answer no, \emph{surely true} \\
\textbf{False positive:} if all $h_i$ are totally random and independent, the probability of error is at most $(1-e^{\nicefrac{-nk}{m}})^k$ \\
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [EXT] Štruktúry pre externú pamäť	
% výpočtový model externej pamäti, cache oblivious model
% B-stromy
% statické cache-oblivious stromy s vEB rozložením
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxEXT}{100}{70}{External Memory}{
\textbf{Model:} infinite slow disk, fast memory with $M$ words; transfer between them in blocks of $B$ words; count number of transfers. \\
\textbf{B-tree:} parameter T; node $v$ has $v.n$ keys and $0$ or $v.n-1$ children; keys are sorted, children contain only values between two keys; all leaves same depth; every node except root $T-1\le v.n \le 2T-1$, root has $1\le v.n \le 2T-1$. Set $T$ so each node fits within $\bigO{1}$ blocks. Height/time for all operations is $\bigO{\log_{B+1} n}$.\\
\textbf{Cache oblivious:} don't know $B$, $M$; block transfers implicit.\\
\textbf{vEB static tree:} \emph{van Emde Boas} memory layout -- cut tree in middle height; get top of $\approx\sqrt{n}$ nodes and $\approx\sqrt{n}$ bottom subtrees each with $\approx\sqrt{n}$; store all recursively.\\
For analysis: look at \emph{level of detail} in above splitting where each subtree fits within $B$ -- will have height $\ge\nicefrac{1}{2}\log B$. If $M\ge 2B$ then need $\bigO{\log_{B+1} n}$ transfers.
}