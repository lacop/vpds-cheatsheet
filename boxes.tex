% For layout testing
\defbox{\boxa}{60}{40}{caption}{content content content content content content content}
\newcommand{\boxb}{\nicebox{60}{20}{caption}{test test test test}}
\newcommand{\boxc}{\nicebox{80}{40}{caption}{bla bla bla bla bla bla}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [AA] Amortizovaná zložitosť
% definícia amortizovanej zložitosti, potenciálová funkcia
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxAA}{100}{55}{Amortized analysis}{
\textbf{Def:} DS supporting operations $o_1,\dots,o_k$.
Amortized time of $o_i$ is $t_i(n)$ if any valid sequence of $n$ operations, in which $o_i$ occurs $n_i$ times, takes total time $\bigO{\sum_j n_jt_j(n)}$.\\
\textbf{Accounting method:} Charge $t_j(n)$ for operation $o_j$. If $t_j(n) >$ cost: distribute the remainder to accounts. If $t_j(n) <$ cost: charge some accounts. Prove non-negative balance at all times.\\
\textbf{Potential method:} $D_i$ is the DS after $i$-th operation, $\Phi(D_i)$ is the DS potential (eg. sum of all accounts). Real cost $c_i$, amortized $\hat{c}_i = c_i + \Phi(D_i) - \Phi(D_{i-1})$. Total cost $\sum_i \hat{c}_i = \sum_i c_i + \Phi(D_n) - \Phi(D_0)$. If $\Phi(D_n)\ge\Phi(D_0)$ then $\hat{c}$ is upper bound on true cost. Usually $\Phi(D_{0})=0$, then need $\Phi(D_i)\ge 0$.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [RMQ] RMQ a LCA
% jednoduché algoritmy
% algoritmy s O(n) predspracovaním a O(1) dotazom
% segmentové stromy
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxRMQrmqlca}{100}{70}{RMQ and LCA}{
\textbf{Trivial:} LCA: no preprocessing, $\bigO{n}$ query; $\bigO{n^3}$ preprocessing, $\bigO{n^2}$ memory, $\bigO{1}$ query; RMQ: \circled{1} $\bigO{n^2}$/$\bigO{1}$.\\
\textbf{RMQ$\to$LCA:} Cartesian tree: root is minimum $A[i]$, left subtree is cartesian tree of $A[<i]$, right is CT of $A[>i]$ (min-heap, in-order traversal is A). Linear time construction: process $A$ left to right, walk up the right spine of the tree.\\
\textbf{LCA$\to\pm 1$RMQ:} Euler tour (DFS) to get depth array, store index of first visit for each node. $\bigO{n}$ preprocessing.\\
\textbf{RMQ in $\bigO{n\log n}$/$\bigO{1}$} \circled{2} (BIG from HW) Store answer for all intervals with length $2^k$. Combine two to answer query.\\
\textbf{$\pm 1$RMQ:} Split to $\nicefrac{2n}{\log n}$ groups of size $n' = \nicefrac{1}{2}\log n$. Store minimum from each group, use \circled{2}. Since $\pm 1$, only $2^{n'} = \sqrt{n}$ different block types (min pos), use \circled{1}: $\bigO{\log^2 n}$ different queries for each type, $\bigO{\log\log n}$ bits for answer, total $\bigO{n}$ preprocess. For final answer compare three candidate positions. 
}

\defbox{\boxRMQsegment}{100}{40}{Segment trees}{
\textbf{Root:} interval $[0,n)$, \textbf{Leafs:} intervals $[i,i+1)$\\
\textbf{Node} $[i,j)$ has children $[i,k)$ and $[k,j)$ where $k = \lfloor\frac{i+j}{2}\rfloor$, stores $A[i]\circ A[i+1]\circ \cdots \circ A[j-1]$. Total $2n-1$ nodes, height $\lceil\log n\rceil$.\\
\textbf{Query:} $A[x]\circ \cdots \circ A[y-1]$ ie $[x, y)$, canonical decomposition, $\bigO{\log n}$ time.\\
\textbf{Can dec:} node $[i,j)$, invariant: overlaps $[x,y)$. If $[i,j) \subseteq [x,y)$ return $\{[i, j)\}$. Else $R := \emptyset$, if $[i,k)$ overlaps $[x,y)$ recurse left, add result to $R$. Same for right child, then return $R$.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [EXT] Štruktúry pre externú pamäť	
% výpočtový model externej pamäti, cache oblivious model
% B-stromy
% statické cache-oblivious stromy s vEB rozložením
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxEXT}{100}{70}{External memory}{
\textbf{Model:} infinite slow disk, fast memory with $M$ words; transfer between them in blocks of $B$ words; count number of transfers. \\
\textbf{B-tree:} parameter T; node $v$ has $v.n$ keys and $0$ or $v.n-1$ children; keys are sorted, children contain only values between two keys; all leaves same depth; every node except root $T-1\le v.n \le 2T-1$, root has $1\le v.n \le 2T-1$. Set $T$ so each node fits within $\bigO{1}$ blocks. Height/time for all operations is $\bigO{\log_{B+1} n}$.\\
\textbf{Cache oblivious:} don't know $B$, $M$; block transfers implicit.\\
\textbf{vEB static tree:} \emph{van Emde Boas} memory layout -- cut tree in middle height; get top of $\approx\sqrt{n}$ nodes and $\approx\sqrt{n}$ bottom subtrees each with $\approx\sqrt{n}$; store all recursively.\\
For analysis: look at \emph{level of detail} in above splitting where each subtree fits within $B$ -- will have height $\ge\nicefrac{1}{2}\log B$. If $M\ge 2B$ then need $\bigO{\log_{B+1} n}$ transfers.
}