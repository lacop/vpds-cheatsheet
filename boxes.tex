% For layout testing
\defbox{\boxa}{60}{40}{caption}{content content content content content content content}
\newcommand{\boxb}{\nicebox{60}{20}{caption}{test test test test}}
\newcommand{\boxc}{\nicebox{80}{40}{caption}{bla bla bla bla bla bla}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [AA] Amortizovaná zložitosť
% definícia amortizovanej zložitosti, potenciálová funkcia
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxAA}{100}{55}{Amortized Analysis}{
\textbf{Def:} DS supporting operations $o_1,\dots,o_k$.
Amortized time of $o_i$ is $t_i(n)$ if any valid sequence of $n$ operations, in which $o_i$ occurs $n_i$ times, takes total time $\bigO{\sum_j n_jt_j(n)}$.\\
\textbf{Accounting method:} Charge $t_j(n)$ for operation $o_j$. If $t_j(n) >$ cost: distribute the remainder to accounts. If $t_j(n) <$ cost: charge some accounts. Prove non-negative balance at all times.\\
\textbf{Potential method:} $D_i$ is the DS after $i$-th operation, $\Phi(D_i)$ is the DS potential (eg. sum of all accounts). Real cost $c_i$, amortized $\hat{c}_i = c_i + \Phi(D_i) - \Phi(D_{i-1})$. Total cost $\sum_i \hat{c}_i = \sum_i c_i + \Phi(D_n) - \Phi(D_0)$. If $\Phi(D_n)\ge\Phi(D_0)$ then $\hat{c}$ is upper bound on true cost. Usually $\Phi(D_{0})=0$, then need $\Phi(D_i)\ge 0$.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [RMQ] RMQ a LCA
% jednoduché algoritmy
% algoritmy s O(n) predspracovaním a O(1) dotazom
% segmentové stromy
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxRMQrmqlca}{100}{70}{RMQ and LCA}{
\textbf{Trivial:} LCA: no preprocessing, $\bigO{n}$ query; $\bigO{n^3}$ preprocessing, $\bigO{n^2}$ memory, $\bigO{1}$ query; RMQ: \circled{1} $\bigO{n^2}$/$\bigO{1}$.\\
\textbf{RMQ$\to$LCA:} Cartesian tree: root is minimum $A[i]$, left subtree is cartesian tree of $A[<i]$, right is CT of $A[>i]$ (min-heap, in-order traversal is A). Linear time construction: process $A$ left to right, walk up the right spine of the tree.\\
\textbf{LCA$\to\pm 1$RMQ:} Euler tour (DFS) to get depth array, store index of first visit for each node. $\bigO{n}$ preprocessing.\\
\textbf{RMQ in $\bigO{n\log n}$/$\bigO{1}$} \circled{2} (BIG from HW) Store answer for all intervals with length $2^k$. Combine two to answer query.\\
\textbf{$\pm 1$RMQ:} Split to $\nicefrac{2n}{\log n}$ groups of size $n' = \nicefrac{1}{2}\log n$. Store minimum from each group, use \circled{2}. Since $\pm 1$, only $2^{n'} = \sqrt{n}$ different block types (min pos), use \circled{1}: $\bigO{\log^2 n}$ different queries for each type, $\bigO{\log\log n}$ bits for answer, total $\bigO{n}$ preprocess. For final answer compare three candidate positions. 
}

\defbox{\boxRMQsegment}{100}{40}{Segment trees}{
\textbf{Root:} interval $[0,n)$, \textbf{Leafs:} intervals $[i,i+1)$\\
\textbf{Node} $[i,j)$ has children $[i,k)$ and $[k,j)$ where $k = \lfloor\frac{i+j}{2}\rfloor$, stores $A[i]\circ A[i+1]\circ \cdots \circ A[j-1]$. Total $2n-1$ nodes, height $\lceil\log n\rceil$.\\
\textbf{Query:} $A[x]\circ \cdots \circ A[y-1]$ ie $[x, y)$, canonical decomposition, $\bigO{\log n}$ time.\\
\textbf{Can dec:} node $[i,j)$, invariant: overlaps $[x,y)$. If $[i,j) \subseteq [x,y)$ return $\{[i, j)\}$. Else $R := \emptyset$, if $[i,k)$ overlaps $[x,y)$ recurse left, add result to $R$. Same for right child, then return $R$.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [SEARCH] Vyhľadávanie kľúčových slov	
% invertovaný index
% lexikografický strom
% prienik triedených zoznamov (doubling search/galloping search)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxSEARCHmain}{100}{55}{Full-Text Keyword Search}{
\textbf{Problem:} preprocess static set of documents (sequences of words) to answer queries: given word $w$ list all documents containing it.\\
\textbf{Inverted index:} store all words along with list of document IDs; see \refbox{inverted index} for storage options. \\
\textbf{Trie:} tree, edges labeled with letters, path from root is a string; store document IDs in nodes where word ends. For $|w|=m$, alphabet size $\sigma$, total word length $D$:\\
{
\centering
\begin{tabular}{r l l l}
\textit{Node edge storage} & \textit{Search} & \textit{Insert} & \textit{Space} \\
Array of size $\sigma$ & \bigO{m} & \bigO{m \sigma} & \bigO{D \sigma}\\
Sorted array & \bigO{m \log \sigma} & \bigO{m \log \sigma + \sigma} & \bigO{D} \\
BST & \bigO{m \log \sigma} & \bigO{m \log \sigma} & \bigO{D}
\end{tabular}
}
}

\defbox{\boxSEARCHinverted}{100}{35}{Inverted Index (Full-Text Keyword Search)}{
For $N$ words ($n$ distinct) of max length $m$ with alphabet size $\sigma$ and result count $p$:\\
{\centering
\begin{tabular}{r l l}
\textit{Index storage} & \textit{Query} & \textit{Preprocessing} \\
Sorted array & \bigO{m \log n + p} & \bigO{mN \log N} \\
BST (balanced) & \bigO{m \log n + p} & \bigO{mN \log n} \\
Hashing & \bigO{m+p}/\bigO{mn+p} & \bigO{mN}/\bigO{mNn} \\
Trie & \bigO{m \log \sigma + p} & \bigO{mn \log \sigma}
\end{tabular}
}
}

\defbox{\boxSEARCHintersection}{90}{35}{Sorted List Intersection (2 Keyword Search)}{
\textbf{Output:} intersection of two sorted lists, lengths $m \le n$.\\
\textbf{Merging:} iterate over both at once: \bigO{m+n}\\
\textbf{Binary search:} iterate over smaller, search through the larger one: \bigO{m \log n}\\
\textbf{Doubling search:} like binary search but \bigO{\log i} (where $i$ is the result) instead of \bigO{\log n} -- double search interval until it overshoots, then binary search; \bigO{m \log \nicefrac{n}{m}}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [HASH] Hešovanie	
% Perkeeftné hešovanie: algoritmus, odhad očakávanej veľkosti pamäte pri univerzálnej triedy hešovacích funkcií
% Bloom Filters - algoritmus, približný odhad pravdepodobnosti chyby
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxHASHph}{90}{35}{Perfect Hashing}{
\textbf{Top level:} universal hash function to table of size $\Theta(N)$ \\
\textbf{Second level:} bucket $i$ with $c_i$ elements hashed to a table of size $\alpha c_i^2$. Expected \# of collisions: $\sum_{\substack{u,v \in X_i\\ u \ne v}} Pr[h(u) = h(v)] \le c_i^2 \frac{c}{m_i} = \frac{c}{\alpha} = \bigO{1}$ \\
\textbf{Search:} $\bigO{1}$ \textbf{Space:} $\bigO{n}$ (deterministic)\\
\textbf{Expected preprocessing time:} $\bigO{n}$\\
}
\defbox{\boxHASHbf}{90}{40}{Bloom Filters}{
\textbf{Representation:} bit string $B[0,\dots,m-1]$ and k hash functions $h_i : U \to \{0, \dots , m-1 \}$ \\
\textbf{Insert(x):} set bits $B[h_1(x)], \dots , B[h_k(x)]$ to 1  \\
\textbf{Contains(x):} check if $B[h_1(x)], \dots , B[h_k(x)]$ are all 1 \\
- if yes, claim x is in the set, \emph{possibility of error} \\
- otherwise answer no, \emph{surely true} \\
\textbf{False positive:} if all $h_i$ are totally random and independent, the probability of error is at most $(1-e^{\nicefrac{-nk}{m}})^k$ \\
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% [EXT] Štruktúry pre externú pamäť	
% výpočtový model externej pamäti, cache oblivious model
% B-stromy
% statické cache-oblivious stromy s vEB rozložením
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\defbox{\boxEXT}{100}{70}{External Memory}{
\textbf{Model:} infinite slow disk, fast memory with $M$ words; transfer between them in blocks of $B$ words; count number of transfers. \\
\textbf{B-tree:} parameter T; node $v$ has $v.n$ keys and $0$ or $v.n-1$ children; keys are sorted, children contain only values between two keys; all leaves same depth; every node except root $T-1\le v.n \le 2T-1$, root has $1\le v.n \le 2T-1$. Set $T$ so each node fits within $\bigO{1}$ blocks. Height/time for all operations is $\bigO{\log_{B+1} n}$.\\
\textbf{Cache oblivious:} don't know $B$, $M$; block transfers implicit.\\
\textbf{vEB static tree:} \emph{van Emde Boas} memory layout -- cut tree in middle height; get top of $\approx\sqrt{n}$ nodes and $\approx\sqrt{n}$ bottom subtrees each with $\approx\sqrt{n}$; store all recursively.\\
For analysis: look at \emph{level of detail} in above splitting where each subtree fits within $B$ -- will have height $\ge\nicefrac{1}{2}\log B$. If $M\ge 2B$ then need $\bigO{\log_{B+1} n}$ transfers.
}